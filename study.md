# study

bfs 求无权边最短路的算法已经写过很多遍了
$O(n)$ 就可以解决问题
`bfs(start: node, end: node, map) -> [node]`  这是python的格式，map是描述地图或者图模型的变量

但是如果需要找到无权图最长路径应该怎么办？
- 可以使用 Dijkstra 算法，直接跑最长路（和最短路的更新方式反着来）
- spfa 算法，边权全部赋值为 -1，然后跑最短路

很遗憾，这是不行的
不能解决 只能走一次的最长路问题（旅行商问题变种）

建议机器学习，遗传退火